from brownie import Contract, a, accounts, ReentrancyExploit, chain, TimelockController
import brownie
from dotmap import DotMap
import pytest

AddressZero = "0x0000000000000000000000000000000000000000"


"""
  POC of ReEntrancy Risk

  Get calldata
  https://ethereum.stackexchange.com/questions/134926/how-to-do-abi-encodewithsignature-in-python-and-eth-brownie
"""

## USDC Transfer
"""
  0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
  NOTE: Just use     transfer_data = usdc.transfer.encode_input(a[1], expected_usdc_transfer_amount)
  0xa9059cbb00000000000000000000000033a4622b82d4c04a53e170c638b944ce27cffce3000000000000000000000000000000000000000000000000000000000000007b
"""

# fixture to deploy TimeController contract
@pytest.fixture()
def deploy():
    deployer = a[0]
    proposer = a[1]
    executor = AddressZero
    veto = a[3]
    supremecourt = a[4]
    cancellor = a[5]

    deployedTC = TimelockController.deploy(
        0,
        [proposer],
        [executor], ## NOTE: This makes the timelock exploitable as well as malicious target
        [veto],
        [supremecourt],
        [cancellor],
        {"from": deployer},
    )
    return DotMap(
        contract=deployedTC,
        deployer=deployer,
        proposer=proposer,
        executor=executor,
        veto=veto,
        supremecourt=supremecourt,
        cancellor=cancellor,
    )

@pytest.fixture()
def expected_usdc_transfer_amount():
  return 123

@pytest.fixture()
def transfer_operation(deploy, expected_usdc_transfer_amount):
    usdc = Contract.from_explorer("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
    transfer_data = usdc.transfer.encode_input(a[1], expected_usdc_transfer_amount)

    ## Send USDC to timelock
    usdc.transfer(deploy.contract, expected_usdc_transfer_amount * 99, {"from": accounts.at("0x0a59649758aa4d66e25f08dd01271e891fe52199", force=True)})


    return DotMap(
        target=usdc,
        value=0,
        data=transfer_data,
        predecessor=0,
        salt="0xc1059ed2dc130227aa1d1d539ac94c641306905c020436c636e19e3fab56fc7f",
        delay=0,
    )

@pytest.fixture()
def malicious_contract():
  c = ReentrancyExploit.deploy({"from": a[0]})
  return c

@pytest.fixture()
def reEntrancy_trigger_operation(malicious_contract):
    return DotMap(
        target=malicious_contract,
        value=1, ## Any value will do, just need to trigger receive / fallback
        data=0,
        predecessor=0,
        salt="0xc1059ed2dc130227aa1d1d539ac94c641306905c020436c636e19e3fab56fc7f",
        delay=0,
    )

# fixture to schedule an operation
@pytest.fixture()
def schedule_operation(deploy, malicious_contract, transfer_operation, reEntrancy_trigger_operation):
    timelock = deploy.contract
    # schedule a proposal

    ## Send 2 wei to trigger the attack
    ## 1 wei per Reentrnancy
    ## NOTE: Exploit contract can be rewritten to send the ETH back to wash-use the ETH
    ## TO KIS we just send all the ETH as it doesn't take away from the POC
    a[0].transfer(timelock, 2)

    targets = [transfer_operation.target.address, reEntrancy_trigger_operation.target.address]
    values = [transfer_operation.value, reEntrancy_trigger_operation.value]
    datas = [transfer_operation.data, reEntrancy_trigger_operation.data]

    predecessor = 0
    salt = "0x"
    delay = 0

    timelock.scheduleBatch(
        targets, 
        values,
        datas,
        predecessor, 
        salt, 
        delay, 
        {"from": deploy.proposer}
    )

    ## Nail in the coffin is making executor open
    id = timelock.hashOperationBatch(targets, values, datas, predecessor, salt)

    ## Setup contract to have malicious payload we need to re-trigger Reentrancy
    malicious_contract.setData(
      id,
      targets, 
      values,
      datas,
      predecessor, 
      salt,
    )

    return id

def test_execute_exploit(deploy, malicious_contract, schedule_operation, transfer_operation, reEntrancy_trigger_operation):
  targets = [transfer_operation.target.address, reEntrancy_trigger_operation.target.address]
  values = [transfer_operation.value, reEntrancy_trigger_operation.value]
  datas = [transfer_operation.data, reEntrancy_trigger_operation.data]
  predecessor = 0
  salt = "0x"

  timelock = deploy.contract

  chain.sleep(123)
  chain.mine()

  ## Check we can do it
  assert timelock.isOperationReady(schedule_operation)

  with brownie.reverts():
    timelock.executeBatch(
      targets, 
      values,
      datas,
      predecessor, 
      salt, 
      {"from": a[0]} ## Critical aspect is requirement that anybody can call this
      ## Because that way we can have the malicious contract call again
    )

